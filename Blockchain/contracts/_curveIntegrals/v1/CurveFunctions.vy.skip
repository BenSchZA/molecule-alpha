# Configure decimal point precision and scaling
DECIMALS: constant(int128) = 18
SCALE: constant(decimal) = convert(10**DECIMALS, decimal)

GRADIENT: constant(decimal) = 0.0000571428 # 1/17500 NB! max 10 decimal places, we're overflowing
VERTICAL_SHIFT: constant(decimal) = 0.5

# , gradientDenominator: uint256, b: uint256

@public
@constant
def curveIntegral(x_t: uint256) -> uint256:
    # Convert scaled uint256 values from Solidity to decimal point values
    _x_t: decimal = convert(x_t, decimal)/SCALE

    # Convert to int128 type for exponentiation operation
    _i128_scale: int128 = convert(SCALE, int128)
    _i128_x_t: int128 = convert(x_t, int128)/_i128_scale

    # Only int128 & uint256 support exponentiation (a**b)
    _i128_sqr: int128 = _i128_x_t**2
    _sqr: decimal = convert(_i128_sqr, decimal)

    # Calculate result and return scaled uint
    result: decimal = (_sqr*GRADIENT)/2.0 + VERTICAL_SHIFT*_x_t
    return convert(result*SCALE, uint256)

@public
@constant
def inverseCurveIntegral(x_d: uint256) -> uint256:
    # Convert scaled uint256 values from Solidity to decimal point values
    _x_d: decimal = convert(x_d, decimal)/SCALE

    # Convert to int128 type for exponentiation operation
    _i128_b: int128 = convert(VERTICAL_SHIFT*SCALE, int128)

    # Only int128 & uint256 support exponentiation (a**b)
    _i128_sqr: int128 = _i128_b**2
    _sqr: decimal = convert(_i128_sqr, decimal)/SCALE/SCALE

    # The sqrt() function only supports decimal type
    arg: decimal = _sqr + 2.0*GRADIENT*_x_d
    sqrt_arg: decimal = sqrt(arg)

    # Calculate result and return scaled uint
    result: decimal = (-VERTICAL_SHIFT + sqrt_arg)/GRADIENT
    return convert(result*SCALE, uint256)


